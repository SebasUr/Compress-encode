#include <stdlib.h>
#include <string.h>

#include "huffman.h"

huffmanNode* createNode(int symbol, uint64_t weight, unsigned long order) {
    huffmanNode* NewNode = (huffmanNode*)malloc(sizeof(huffmanNode));
    if (NewNode == NULL) { return NULL; }

    NewNode->weight = weight;
    NewNode->symbol = symbol; 
    NewNode->left = NULL;
    NewNode->right = NULL;
    NewNode->order = order;

    return NewNode;
}

// const int para no modificar f_s
size_t initializeTree(const int f_s[], huffmanNode* activeNodes[]) {
    size_t count = 0;
    unsigned long next_order = 0;
    for (int i = 0; i < 256; i++){
        if (f_s[i] > 0){
            activeNodes[count++] = createNode(i, (uint64_t)f_s[i], next_order++);
        }
    }
    return count;
}

int nodeComparator(const void *a, const void *b) {
    const huffmanNode *nodeA = *(const huffmanNode **)a;
    const huffmanNode *nodeB = *(const huffmanNode **)b;

    // Comparar por peso
    if(nodeA->weight < nodeB->weight) return -1;
    if(nodeA->weight > nodeB->weight) return 1;

    // Comparar por orden en caso de empate en peso
    if(nodeA->order < nodeB->order) return -1;
    if(nodeA->order > nodeB->order) return 1;
    return 0;
}

huffmanNode* huffmanAlgorithm(const int f_s[], huffmanNode* activeNodes[]) {
    size_t count = initializeTree(f_s, activeNodes);
    qsort(activeNodes, count, sizeof(huffmanNode*), nodeComparator);

    while(count > 1){
        huffmanNode* firstA = activeNodes[0];
        huffmanNode* firstB = activeNodes[1];

        unsigned long parent_order = (a->order < b->order) ? a->order : b->order;
        huffmanNode* p_node = createNode(-1, firstA->weight + firstB->weight, parent_order);

        p_node->left = firstA;
        p_node->right = firstB;

        // Correr arreglo hacia la izquierda (Eliminar 0 y 1)
        if(count>2){
            memmove(&activeNodes[0], &activeNodes[2], (count-2)*sizeof(activeNodes[0]));
        }
        count -= 2;

        // Insertar el nuevo nodo en la posici√≥n correcta
        // Ver donde insertarlo
        size_t pos = 0;
        while(pos<count && (activeNodes[pos]->weight < p_node-> weight || 
            (activeNodes[pos]->weight== p_node->weight && activeNodes[pos]->order <= p_node->order))){
            
            pos++;
        }

        // Hacer espacio para el nuevo nodo
        if (pos < 256){
            memmove(&activeNodes[pos+1], &activeNodes[pos], (count - pos) * sizeof(activeNodes[0]));
        }

        // Insertar el nuevo nodo
        activeNodes[pos] = p_node;
        count +=1;
    }

    huffmanNode* root = activeNodes[0];
    return root;
}

void freeHuffmanTree(huffmanNode* root) {
    if (root == NULL) {
        return;
    }
    freeHuffmanTree(root->left);
    freeHuffmanTree(root->right);
    free(root);
}



